// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"sync"

	"github.com/umputun/feed-master/app/youtube/channel"
)

// StoreServiceMock is a mock implementation of youtube.StoreService.
//
// 	func TestSomethingThatUsesStoreService(t *testing.T) {
//
// 		// make and configure a mocked youtube.StoreService
// 		mockedStoreService := &StoreServiceMock{
// 			ExistFunc: func(entry channel.Entry) (bool, error) {
// 				panic("mock out the Exist method")
// 			},
// 			LoadFunc: func(channelID string, max int) ([]channel.Entry, error) {
// 				panic("mock out the Load method")
// 			},
// 			RemoveOldFunc: func(channelID string, keep int) ([]string, error) {
// 				panic("mock out the RemoveOld method")
// 			},
// 			SaveFunc: func(entry channel.Entry) (bool, error) {
// 				panic("mock out the Save method")
// 			},
// 		}
//
// 		// use mockedStoreService in code that requires youtube.StoreService
// 		// and then make assertions.
//
// 	}
type StoreServiceMock struct {
	// ExistFunc mocks the Exist method.
	ExistFunc func(entry channel.Entry) (bool, error)

	// LoadFunc mocks the Load method.
	LoadFunc func(channelID string, max int) ([]channel.Entry, error)

	// RemoveOldFunc mocks the RemoveOld method.
	RemoveOldFunc func(channelID string, keep int) ([]string, error)

	// SaveFunc mocks the Save method.
	SaveFunc func(entry channel.Entry) (bool, error)

	// calls tracks calls to the methods.
	calls struct {
		// Exist holds details about calls to the Exist method.
		Exist []struct {
			// Entry is the entry argument value.
			Entry channel.Entry
		}
		// Load holds details about calls to the Load method.
		Load []struct {
			// ChannelID is the channelID argument value.
			ChannelID string
			// Max is the max argument value.
			Max int
		}
		// RemoveOld holds details about calls to the RemoveOld method.
		RemoveOld []struct {
			// ChannelID is the channelID argument value.
			ChannelID string
			// Keep is the keep argument value.
			Keep int
		}
		// Save holds details about calls to the Save method.
		Save []struct {
			// Entry is the entry argument value.
			Entry channel.Entry
		}
	}
	lockExist     sync.RWMutex
	lockLoad      sync.RWMutex
	lockRemoveOld sync.RWMutex
	lockSave      sync.RWMutex
}

// Exist calls ExistFunc.
func (mock *StoreServiceMock) Exist(entry channel.Entry) (bool, error) {
	if mock.ExistFunc == nil {
		panic("StoreServiceMock.ExistFunc: method is nil but StoreService.Exist was just called")
	}
	callInfo := struct {
		Entry channel.Entry
	}{
		Entry: entry,
	}
	mock.lockExist.Lock()
	mock.calls.Exist = append(mock.calls.Exist, callInfo)
	mock.lockExist.Unlock()
	return mock.ExistFunc(entry)
}

// ExistCalls gets all the calls that were made to Exist.
// Check the length with:
//     len(mockedStoreService.ExistCalls())
func (mock *StoreServiceMock) ExistCalls() []struct {
	Entry channel.Entry
} {
	var calls []struct {
		Entry channel.Entry
	}
	mock.lockExist.RLock()
	calls = mock.calls.Exist
	mock.lockExist.RUnlock()
	return calls
}

// Load calls LoadFunc.
func (mock *StoreServiceMock) Load(channelID string, max int) ([]channel.Entry, error) {
	if mock.LoadFunc == nil {
		panic("StoreServiceMock.LoadFunc: method is nil but StoreService.Load was just called")
	}
	callInfo := struct {
		ChannelID string
		Max       int
	}{
		ChannelID: channelID,
		Max:       max,
	}
	mock.lockLoad.Lock()
	mock.calls.Load = append(mock.calls.Load, callInfo)
	mock.lockLoad.Unlock()
	return mock.LoadFunc(channelID, max)
}

// LoadCalls gets all the calls that were made to Load.
// Check the length with:
//     len(mockedStoreService.LoadCalls())
func (mock *StoreServiceMock) LoadCalls() []struct {
	ChannelID string
	Max       int
} {
	var calls []struct {
		ChannelID string
		Max       int
	}
	mock.lockLoad.RLock()
	calls = mock.calls.Load
	mock.lockLoad.RUnlock()
	return calls
}

// RemoveOld calls RemoveOldFunc.
func (mock *StoreServiceMock) RemoveOld(channelID string, keep int) ([]string, error) {
	if mock.RemoveOldFunc == nil {
		panic("StoreServiceMock.RemoveOldFunc: method is nil but StoreService.RemoveOld was just called")
	}
	callInfo := struct {
		ChannelID string
		Keep      int
	}{
		ChannelID: channelID,
		Keep:      keep,
	}
	mock.lockRemoveOld.Lock()
	mock.calls.RemoveOld = append(mock.calls.RemoveOld, callInfo)
	mock.lockRemoveOld.Unlock()
	return mock.RemoveOldFunc(channelID, keep)
}

// RemoveOldCalls gets all the calls that were made to RemoveOld.
// Check the length with:
//     len(mockedStoreService.RemoveOldCalls())
func (mock *StoreServiceMock) RemoveOldCalls() []struct {
	ChannelID string
	Keep      int
} {
	var calls []struct {
		ChannelID string
		Keep      int
	}
	mock.lockRemoveOld.RLock()
	calls = mock.calls.RemoveOld
	mock.lockRemoveOld.RUnlock()
	return calls
}

// Save calls SaveFunc.
func (mock *StoreServiceMock) Save(entry channel.Entry) (bool, error) {
	if mock.SaveFunc == nil {
		panic("StoreServiceMock.SaveFunc: method is nil but StoreService.Save was just called")
	}
	callInfo := struct {
		Entry channel.Entry
	}{
		Entry: entry,
	}
	mock.lockSave.Lock()
	mock.calls.Save = append(mock.calls.Save, callInfo)
	mock.lockSave.Unlock()
	return mock.SaveFunc(entry)
}

// SaveCalls gets all the calls that were made to Save.
// Check the length with:
//     len(mockedStoreService.SaveCalls())
func (mock *StoreServiceMock) SaveCalls() []struct {
	Entry channel.Entry
} {
	var calls []struct {
		Entry channel.Entry
	}
	mock.lockSave.RLock()
	calls = mock.calls.Save
	mock.lockSave.RUnlock()
	return calls
}
